---
title: "Sensitivity & Specificty Analysis of MDS Rank"
author: "Rohan Mishra"
date: "10/21/2022"
output: html_document
editor_options: 
  chunk_output_type: console
---
```{r setup, include=FALSE}

rm(list=ls())
library(lsa)
library(qcc)
library(fda)
library(plotly)
library(HMPTrees)
library(tidyverse)
library(gridExtra)
library(grid)
options(scipen=9999)
options(max.print = 10000000) 
z_trans <- function(r) 0.5*(log(1+r, base = exp(1))-log(1-r, base = exp(1))) 
knitr::opts_chunk$set(echo = TRUE)


#############
#dataFei <- read.csv("/mnt/DATA/Fei/cstr_functional_ontology_synethic_08242022.csv") 

# dataFei <- read.csv("/mnt/DATA/testForSensSpec.csv")
# 
# # dataFei_sp <- split(dataFei, f=dataFei$Replicate)
# # #for(i in 1:6) {
# # dataFei <- dataFei_sp[[i]]
# 
# par(mfrow=c(3,2))
# plot(dataFei$concentrationA, type = "l", main = "Concentration of A");grid();#abline(v=seq(0,5000,by=50)); 
# plot(dataFei$Temp, type = "l", main = "Reactor Temperature");grid();#abline(v=seq(0,5000,by=50))
# 
# plot(dataFei$coolingTemp, type = "l", main = "Cooling Temperature");grid();#abline(v=seq(0,5000,by=50))
# plot(dataFei$Temp_inlet, type = "l", main = "Inlet Temperature");grid();#abline(v=seq(0,5000,by=50))
# lines(smooth.spline(dataFei$Temp_inlet, spar = 0.2), col = "red", lwd=2)
# 
# plot(dataFei$flowRate, type = "l", main = "Flow Rate");grid();#abline(v=seq(0,5000,by=50))
# lines(smooth.spline(dataFei$flowRate, spar = 0.2), col = "red", lwd = 2)
# plot(dataFei$concentrationA_inlet, type = "l", main = "Inlet Concentration of A");grid();#abline(v=seq(0,5000,by=50))
# lines(smooth.spline(dataFei$concentrationA_inlet, spar = 0.2), col = "red", lwd = 2)

###########

stableData <- read.csv("/mnt/DATA/Sens_Spec/Data/testForSensSpec_stable_6runs.csv")
s_reps <- data.frame(Replicate = unique(stableData$Replicate) , Rep_Num = paste("S",1:length(unique(stableData$Replicate)),sep = "_"))
stableData <- stableData %>%
  inner_join(s_reps, by = "Replicate") 

# stableData %>%
#   ggplot(aes(x=time,y=concentrationA, color = Rep_Num, group = Rep_Num)) + 
#   geom_line() + theme(legend.position = "none")

s <- stableData %>%
  select(time, concentrationA, Rep_Num) %>%
  pivot_wider(names_from = "Rep_Num", values_from = "concentrationA") 
s <- s %>%
  mutate(Mean = apply(s[,-1], 1,mean),
         SD = apply(s[,-c(1)],1,sd),
         Lower = Mean - 1.96*(SD/6),
         Upper = Mean + 1.96*(SD/6)) 

#######
#apply(s,2,summary) 

# plot(s$time, s$S_1, type = "l", col = "black", ylim=c(0,1))
# lines(s$time, s$S_2,col = "red")
# lines(s$time, s$S_3,col = "blue")
# lines(s$time, s$S_4,col = "green")
# lines(s$time, s$S_5,col = "purple")
# lines(s$time, s$S_6,col = "orange")
# lines(s$time, s$Lower,col = "red")
# lines(s$time,s$Mean, col = "black", lwd=3)
# lines(s$time, s$Upper,col = "red", lty=2, lwd=2)

# par(mfrow=c(1,1))
# plot(s$time,s$Mean, type="l",lty=1,col = "black", ylim=c(0,1),lwd=2)
# lines(s$time, s$Lower,col = "red", lty=2, lwd=2)
# lines(s$time, s$Upper,col = "red", lty=2, lwd=2)



#%>%
#  pivot_longer(S_1:Upper, names_to = "Group", values_to = "concentrationA") 

# stableData %>% #does not work
#   ggplot(aes(x=time,y=concentrationA)) + geom_ribbon(data = s, aes(ymin=Lower,ymax=Upper))
#######

unstableData <- read.csv("/mnt/DATA/Sens_Spec/Data/testForSensSpec_unstable_6runs.csv")
u_reps <- data.frame(Replicate = unique(unstableData$Replicate) , Rep_Num = paste("US",1:length(unique(stableData$Replicate)),sep = "_"))
unstableData <- unstableData %>%
  inner_join(u_reps, by = "Replicate") 

# unstableData %>%
#   ggplot(aes(x=time,y=concentrationA, color = Replicate, group = Replicate)) + 
#   geom_line() + 
#   theme(legend.position = "none")

u <- unstableData %>%
  select(time, concentrationA, Rep_Num) %>%
  pivot_wider(names_from = "Rep_Num", values_from = "concentrationA") 
u <- u %>%
  mutate(Mean = apply(u[,-1], 1,mean),
         SD = apply(u[,-c(1)],1,sd),
         Lower = Mean - 1.96*(SD/6),
         Upper = Mean + 1.96*(SD/6)) 

#apply(u,2,summary)
#########
# plot(u$time, u$US_1, type = "l", col = "black", ylim=c(0,1))
# lines(u$time, u$US_2,col = "red")
# lines(u$time, u$US_3,col = "blue")
# lines(u$time, u$US_4,col = "green")
# lines(u$time, u$US_5,col = "purple")
# lines(u$time, u$US_6,col = "orange")
# lines(u$time, u$Lower,col = "red")
# lines(u$time,u$Mean, col = "black", lwd=3)
# lines(u$time, u$Upper,col = "red", lty=2, lwd=2)
#########
par(mfrow=c(1,1))
plot(u$time,u$Mean, type="l",lty=1,col = "black", ylim=c(0,1),lwd=3);grid()
lines(u$time, u$Lower,col = "red", lty=2, lwd=2)
lines(u$time, u$Upper,col = "red", lty=2, lwd=2)

lines(s$time, s$Mean, col = "black", lwd=3, lty=1)
lines(s$time, s$Lower,col = "blue", lty=2, lwd=2)
lines(s$time, s$Upper,col = "blue", lty=2, lwd=2)
title(main = "Mean & 95% CI Curves for Stable & Unstable Runs")
legend("topleft", legend = c("Stable", "Unstable"), fill = c("blue","red"))


# ##########
# 
# stableData2 <- read.csv("/mnt/DATA/testForSensSpec_stable_120runs.csv")
# s_reps <- data.frame(Replicate = unique(stableData2$Replicate) , Rep_Num = paste("S",1:length(unique(stableData2$Replicate)),sep = "_"))
# stableData2 <- stableData2 %>%
#   inner_join(s_reps, by = "Replicate") 
# 
# unstableData2 <- read.csv("/mnt/DATA/testForSensSpec_unstable_120runs.csv")
# u_reps <- data.frame(Replicate = unique(unstableData2$Replicate) , Rep_Num = paste("US",1:length(unique(unstableData2$Replicate)),sep = "_"))
# unstableData2 <- unstableData2 %>%
#   inner_join(u_reps, by = "Replicate") 
# 
# 
# reps_interest <- c(paste("S", 1:100, sep="_"), paste("US", 1:100, sep = "_"))
# 
# bigData <- rbind(stableData2, unstableData2) %>% as.data.frame()
# bigData <- bigData %>%
#   filter(Rep_Num %in% reps_interest)
# 
# 
# 
# 
# # bigData %>%
# #   ggplot(aes(x=time, y=concentrationA, color = Replicate, group = Replicate)) + geom_line()
# 
# bigData_sp <- bigData2 %>%
#   split(f=bigData$Rep_Num)
# 
# bigData_sp <- bigData_sp[lapply(bigData_sp, nrow) >0]
# saveRDS(bigData_sp, "/mnt/DATA/big_sens_spec_data_list.rds")



```


```{r algorithm}

#bigData_sp <- read_rds("/mnt/DATA/big_sens_spec_data_list.rds")

bigData <- rbind(stableData, unstableData)
bigData_sp <- split(bigData, f=bigData$Rep_Num)
#violations_all_data_for <- list()
cors_all_data <- lapply(bigData_sp, function(z) {


  z$Group <- cut(1:5001,100,labels = FALSE)
  
  z1 <- split(z, f=z$Group)

  cor_mats <- lapply(z1, function(i){
    d2 <- i %>%
      select(coolingTemp:Temp) %>%
      cor()
  })
  
  
  z_c <- lapply(z1, function(i){
    d2 <- i %>% 
      select(coolingTemp:Temp) %>%
      cor()
    d2 <- d2[upper.tri(d2)]
    return(d2)
  }) %>%
    bind_rows() %>% t()
  
  x <- c('Tc',"Ai","Ti", "FR","Ac","T")

  results <- NULL
  for(j in 2:6){
    for(i in 1:(j-1)) {
      #print(c(i,j))
      results <- c(results, (paste(x[i], x[j])))
    }
  }
  colnames(z_c) <- results
  ##########
  z_c[is.na(z_c)] <- 0
  return(z_c)
}) 
#saveRDS(cors_all_data, "/mnt/DATA/Sens_Spec/Results/Corrs_6S_v_6US.rds")

QCC_all_data <- lapply(cors_all_data, function(z_c){ 
#for(i in 1:12)  
  color <- rainbow(3)
  
  par(mfrow=c(1,1))
  QCCs <- list()
  QCCData <- list()
  for(i in 1:81){
    #print(i)
    index <- i+19
    h <- z_c[1:index,]
    h <- apply(h,2,z_trans)
    QCCs[[i]] <- cmdscale(dist(h),k=1) %>% as.data.frame()
    QCCs[[i]]$Index <- 1:nrow(QCCs[[i]])
    QCCs[[i]]$Rank <- rank(QCCs[[i]]$V1)
  
    QCCData[[i]] <-  qcc(QCCs[[i]]$Rank[1:18], type = "xbar.one",
                         newdata = QCCs[[i]]$Rank[19:length(QCCs[[i]]$Rank)], plot = FALSE)
    
    
    #Sys.sleep(3)
  }
  return(QCCData)
}) 
#saveRDS(QCC_all_data, "/mnt/DATA/Sens_Spec/Results/QCCs_6S_v_6US.rds")


violations_all_data <- lapply(QCC_all_data, function(QCCData){
  
  QCCViolationsData <- lapply(QCCData, function(i) unlist(i$violations) %>% unique() %>% length()) %>% unlist()
  #violations_all_data_for[[i]] <- QCCViolationsData
  
  return(QCCViolationsData)
 
})%>%
  bind_cols() %>% t()
#saveRDS(violations_all_data, "/mnt/DATA/Sens_Spec/Results/Violations_6S_v_6US.rds")

```

SENSITIVITY = TP/(TP+FN)

SPECIFICITY = TN/(TN+FP)


Positive = UNSTABLE
Negative = STABLE

True Positive = Predicted UNSTABLE, Truly STABLE
False Negative = Predicted STABLE, Truly UNSTABLE
True Negative = Predicted STABLE, Truly STABLE
False Positive = Predicted UNSTABLE, Truly STABLE


```{r calculate Sens & Spec 6 v 6}

q <- violations_all_data %>%
  as.data.frame() %>%
  mutate(True_Mode = c(rep("Stable",6), rep("Unstable", 6))) %>%
  select(True_Mode, V1:V81)

# q <- data.frame(ID = rownames(violations_all_data) , 
#                 True_Mode = c(rep("Stable",6), rep("Unstable", 6))) %>% t()


rownames(q) <- rownames(violations_all_data)

# cutpoints_mat <- data.frame(matrix(NA,nrow=101,ncol = 12))
# 
# 
# cutpoints_mat <- apply(violations_all_data, 1, function(a) ifelse(sum(a >= 0),1,0))

cutpoints_mat <- NULL
for(i in 0:81) {
  cutpoints_mat <- rbind(cutpoints_mat, 
                         apply(violations_all_data, 1, function(a){
                           ifelse(sum(a >= i-1),1,0)
                           })
                         )
                         
}
# colnames(cutpoints_mat) <- c("S1","S2","S3","S4","S5","S6",
#                              "US1","US2","US3","US4","US5","US6") #rename to c(S1:S6, US1:US6) find a way to automate for any # runs

# cutpoints_mat[cutpoints_mat !=0] = "U"
# cutpoints_mat[cutpoints_mat == 0] = "S"

conf_mat <- apply(cutpoints_mat,1, function(a) {
  table(a %>% factor(levels = 0:1)
        , 
        q[,1] %>% factor(levels = c("Stable", "Unstable"))
        )
  })


final_df <- data.frame(cutpoint = 0:81,
                       sens = apply(conf_mat, 2,function(a){
                         a[4]/(a[4] + a[3])   ### TP/(TP+FN)
                         }),
                       
                       spec = apply(conf_mat,2, function(a){
                         a[1]/(a[1] + a[2])    ### TN/(TN+FP)
                         })
                       )

par(mfrow=c(1,1))
plot((1-final_df$spec), final_df$sens, type = "l", lwd=2);grid()
abline(a=0,b=1, lty=2)

```

POSITIVE = UNSTABLE 
NEGATIVE = STABLE

[1,1] = TN
[2,1] = FP
[1,2] = FN
[2,2] = TP

```{r calculate Sens & Spec 100 v 100}

QCC_all_data <- read_rds("/mnt/DATA/Sens_Spec/Results/QCCs_100S_v_100US.rds")
violations_all_data <- read_rds("/mnt/DATA/Sens_Spec/Results/Violations_100S_v_100US.rds")

q <- violations_all_data %>%
  as.data.frame() %>%
  mutate(True_Mode = c(rep("Stable",100), rep("Unstable", 100))) %>%
  select(True_Mode, V1:V81)

# q <- data.frame(ID = rownames(violations_all_data) , 
#                 True_Mode = c(rep("Stable",6), rep("Unstable", 6))) %>% t()


rownames(q) <- rownames(violations_all_data)

# cutpoints_mat <- data.frame(matrix(NA,nrow=101,ncol = 12))
# 
# 
# cutpoints_mat <- apply(violations_all_data, 1, function(a) ifelse(sum(a >= 0),1,0))

cutpoints_mat <- NULL
for(i in 0:81) {
  cutpoints_mat <- rbind(cutpoints_mat, 
                         apply(violations_all_data, 1, function(a){
                           ifelse(sum(a >= i-1),1,0)
                           })
                         )
                         
}
# colnames(cutpoints_mat) <- c("S1","S2","S3","S4","S5","S6",
#                              "US1","US2","US3","US4","US5","US6") #rename to c(S1:S6, US1:US6) find a way to automate for any # runs

# cutpoints_mat[cutpoints_mat !=0] = "U"
# cutpoints_mat[cutpoints_mat == 0] = "S"

conf_mat <- apply(cutpoints_mat,1, function(a) {
  table(a %>% factor(levels = 0:1)
        , 
        q[,1] %>% factor(levels = c("Stable", "Unstable"))
        )
  })


final_df <- data.frame(cutpoint = 0:81,
                       sens = apply(conf_mat, 2,function(a){
                         a[4]/(a[4] + a[3])   ### TP/(TP+FN)
                         }),
                       
                       spec = apply(conf_mat,2, function(a){
                         a[1]/(a[1] + a[2])    ### TN/(TN+FP)
                         })
                       )

par(mfrow=c(1,1))
plot((1-final_df$spec), final_df$sens, type = "l", lwd=2);grid()
abline(a=0,b=1, lty=2)

```




```{r Stable vs Unstable Violations Step Plots}

#head(violations_all_data)


plot(1:81,violations_all_data[19,],ylim=c(0,100), type = "step")
lines(1:81,violations_all_data[31,],type = "step", col = "red");grid()

plot(QCC_all_data[[19]][[19]])
plot(QCC_all_data[[19]][[20]])
plot(QCC_all_data[[19]][[21]])

plot(QCC_all_data[[31]][[12]])
plot(QCC_all_data[[31]][[13]])
plot(QCC_all_data[[31]][[14]])


par(mfrow=c(1,1))
plot(1:81,violations_all_data[200,],ylim=c(0,100), type = "step")
lines(1:81,violations_all_data[150,], type = "step", col = "blue")
lines(1:81,violations_all_data[125,], type = "step", col = "green")





plot(QCC_all_data[[200]][[40]])
plot(QCC_all_data[[200]][[60]])
plot(QCC_all_data[[200]][[80]])

plot(QCC_all_data[[150]][[40]])
plot(QCC_all_data[[150]][[60]])
plot(QCC_all_data[[150]][[80]])


plot(QCC_all_data[[125]][[40]])
plot(QCC_all_data[[125]][[60]])
plot(QCC_all_data[[125]][[80]])





```


PSEUDOCODE:

1. Read in the data - read.file(filepath)
2. Split the data into timepoints of our choice - split(data, interval_length)
3. Choose sensors of interest and calculate correlations between each pair of sensors- convert ot tabular format with upper.tri(corr_matrix)- any NA correlation values become 0
4. In an updating fashion, calculate pairwise distances between all rows of correlations and perform a 1 dimensional scale on distance values.
  - Updating meaning: pairwise & 1DS on first 20 corr graphs, then 21, then 22, ... up to the total # of graphs in the process
5. Plot the 1dimensional scale values in a QCC Plot
6. DECISION RULE: multiple consecutive increases in # of violations run to run


