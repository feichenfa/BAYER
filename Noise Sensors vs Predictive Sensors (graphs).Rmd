---
title: "Noise Sensors vs Predictive Sensors"
author: "Rohan Mishra"
date: "11/3/2022"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}

rm(list=ls())
library(lsa)
library(qcc)
library(fda)
library(plotly)
library(HMPTrees)
library(tidyverse)
library(gridExtra)
library(grid)
options(scipen=9999)
options(max.print = 10000000) 
z_trans <- function(r) 0.5*(log(1+r, base = exp(1))-
                              log( 1-ifelse(r==1, .999999,r) , base = exp(1))) 
knitr::opts_chunk$set(echo = TRUE)



dataFei <- read.csv("/mnt/DATA/Fei/cstr_functional_ontology_synethic_08242022.csv") 

```

```{r plot the data}

par(mfrow=c(3,2))
plot(dataFei$concentrationA, type = "l", main = "Concentration of A");grid();#abline(v=seq(0,5000,by=50)); 
plot(dataFei$Temp, type = "l", main = "Reactor Temperature");grid();#abline(v=seq(0,5000,by=50))

plot(dataFei$coolingTemp, type = "l", main = "Cooling Temperature");grid();#abline(v=seq(0,5000,by=50))
plot(dataFei$Temp_inlet, type = "l", main = "Inlet Temperature");grid();#abline(v=seq(0,5000,by=50))
lines(smooth.spline(dataFei$Temp_inlet, spar = 0.2), col = "red", lwd=2)

plot(dataFei$flowRate, type = "l", main = "Flow Rate");grid();#abline(v=seq(0,5000,by=50))
lines(smooth.spline(dataFei$flowRate, spar = 0.2), col = "red", lwd = 2)
plot(dataFei$concentrationA_inlet, type = "l", main = "Inlet Concentration of A");grid();#abline(v=seq(0,5000,by=50))
lines(smooth.spline(dataFei$concentrationA_inlet, spar = 0.2), col = "red", lwd = 2)

```


```{r algorithm}

# p_sensors <- c("concentrationA", "Temp", "coolingTemp")
# 
# n_sensors <-  c("Temp_inlet", "flowRate", "concentrationA_inlet")

z <- dataFei 

z$coolingTemp <- z$coolingTemp + runif(5001,-10,10)
z$Group <- cut(1:5001,100,labels = FALSE)

z1 <- split(z, f=z$Group)
#i <- z1[[1]]



z_c <- lapply(z1, function(i){
  d2 <- i %>%
    select(coolingTemp:Temp) %>%
    #select(Temp_inlet, flowRate, concentrationA_inlet) %>%
    #select(concentrationA, Temp, coolingTemp) %>%
    cor()
  d2 <- d2[upper.tri(d2)]
  return(d2)
}) %>%
  bind_rows() %>% t()


head(z_c)


###### FOR LOOP #############

par(mfrow=c(2,1))



### setting the names of table of graphs #######
x <- c('Tc',"Ai","Ti", "FR","Ac","T")
x <- c("Ac","T", "Tc")
x <- c("Ti", "FR", "Ai")

results <- NULL
for(j in 2:length(x)){
  for(i in 1:(j-1)) {
    #print(c(i,j))
    results <- c(results, print(paste(x[i], x[j])))
  }
}
colnames(z_c) <- results
###########

color <- rainbow(6)

par(mfrow=c(2,2))
QCCs <- list()
QCCData <- list()
for(i in 1:81){
  print(i)
  index <- i+19
  z <- z_c[1:index,]
  z <- apply(z,2,z_trans)
  QCCs[[i]] <- cmdscale(dist(z),k=1) %>% as.data.frame()
  QCCs[[i]]$Index <- 1:nrow(QCCs[[i]])
  QCCs[[i]]$Rank <- rank(QCCs[[i]]$V1)
  #plot(1:nrow(QCCs[[i]]), QCCs[[i]]$Rank, type = "step")
  #par(mfrow=c(3,3))
  # ts.plot(z[,c(7:10,15)], lty=1, col=color, ylim=c(-2,2),lwd=2,
  #         main = "Con A Corrs");grid(lwd=2)
  # ts.plot(z[,c(11:15)], lty=1, col=color, ylim=c(-2,2),lwd=2,
  #         main = "Reactor Temp Corrs");grid(lwd=2)
  # ts.plot(z[,c(4:6,10,14)], lty=1, col=color, ylim=c(-2,2),lwd=2,
  #         main = "Flow Rate Corrs");grid(lwd=2)
  # ts.plot(z[,c(1,3,5,8,12)], lty=1, col=color, ylim=c(-2,2),lwd=2,
  #         main = "ConA In");grid(lwd=2)
  # ts.plot(z[,c(1,2,4,7,11)], lty=1, col=color, ylim=c(-2,2),lwd=2,
  #         main = "Cooling Temp");grid(lwd=2)
  # ts.plot(z[,c(2,3,6,9,13)], lty=1, col=color, ylim=c(-2,2),lwd=2,
  #         main = "Inlet Temp");grid(lwd=2)

  QCCData[[i]] <-  qcc(QCCs[[i]]$Rank[1:18], 
                       type = "xbar.one", 
                       newdata = QCCs[[i]]$Rank[19:length(QCCs[[i]]$Rank)],
                       title="MDS Rank QCC")#; grid(lwd=2)
  
  Sys.sleep(1)
}

QCCViolationsData <- lapply(QCCData, function(i) c(i$violations$violating.runs, i$violations$beyond.limits))



### stepwise for loop
QCCs <- list()
QCCData <- list()
violations <- rep(0,19)
par(mfrow=c(2,1))
for(i in 1:81){
  index <- i+19
  z <- z_c[1:index,]
  z <- apply(z,2,z_trans)
  QCCs[[i]] <- cmdscale(dist(z),k=1) %>% as.data.frame()
  QCCs[[i]]$Index <- 1:nrow(QCCs[[i]])
  QCCs[[i]]$Rank <- rank(QCCs[[i]]$V1)
  

  QCCData[[i]] <-  qcc(QCCs[[i]]$Rank[1:18], 
                       type = "xbar.one", 
                       newdata = QCCs[[i]]$Rank[19:length(QCCs[[i]]$Rank)],
                       title="MDS Rank QCC", plot=FALSE)#; grid(lwd=2)
  
  violations[i+19] <- unlist(QCCData[[i]]$violations) %>% unique() %>% length()
  plot(x=1:(i+19), y=violations,type="step", main = "# of Violations")
  plot(QCCData[[i]], main="MDS Rank QCC")
  
  
  #Sys.sleep(0.5)
}





# par(mfrow=c(1,1))
# f <- cmdscale(dist(z_c),k=1) %>% as.data.frame()
# f$Index <- 1:nrow(f)
# f$Rank <- rank(f$V1)
# plot(1:nrow(f), f$Rank, type = "step")
# q <- qcc::qcc(f$Rank[1:40], type = "xbar.one", newdata = f$Rank[41:100])
# 
# violations <- c(q$violations$beyond.limits, q$violations$violating.runs)
# non_violations <- setdiff(c(1:100), violations)
# wilcox.test(violations, non_violations)


```